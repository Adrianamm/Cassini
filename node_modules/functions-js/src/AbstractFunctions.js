/*
 * This file is part of the UCSDMath package.
 *
 * (c) 2015-2018 UCSD Mathematics | Math Computing Support <mathhelp@math.ucsd.edu>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*jshint globalstrict: true, esversion: 6 */

'use strict';

/**
 * AbstractFunctions provides an abstract base class implementation/interface for subclasses.
 * This service groups a common code base implementation that all `Functions` extends.
 *
 * This component library is used to service common routines not found in other services.
 *
 * Method list: (+) @api, (-) protected or private visibility.
 *
 * (+) {Object} constructor();
 * (+) {void}   setConstants();
 * (+) {void}   setProperties();
 * (+) {string} sprintf();
 * (+) {string} getUuid4();
 * (+) {string} left(string str, int n);
 * (+) {string} right(string str, int n);
 * (+) {Array}  array_values(string list);
 * (+) {Array}  array_merge(array one, array two, ...);
 * (+) {bool}   array_key_exists(string key, array list);
 * (+) {string} leftPad(string str, string char, int n);
 * (+) {string} rightPad(string str, string char, int n);
 * (+) {bool}   in_array(needle, haystack, paramStrict = false);
 * (+) {Array}  explode(string delimiter, string input, int limit);
 * (+) {Array}  array_keys(array array, string searchValue = null, bool paramStrict = false);
 * (+) {string} getVersion();
 * (+) {string} showType(mixed obj);
 * (+) {string} getClassName(object obj);
 *
 * @author Daryl Eisner <deisner@ucsd.edu>
 */
class AbstractFunctions
{
    /**
     * Constants.
     *
     * @var {string}  version The version number
     * @var {integer} DECIMAL The base number used in calculations
     *
     * @api
     */
    setConstants()
    {
        this.version = '1.28.0';
        this.DECIMAL = 10;
    }

    //--------------------------------------------------------------------------

    /**
     * Properties.
     *
     * @var {string} pid The UCSD Personal ID number
     * @var {string} eid The UCSD Employee ID number
     * @var {string} aid The UCSD Associate ID number
     */
    setProperties()
    {
        this.pid = null;
        this.eid = null;
        this.aid = null;
    }

    //--------------------------------------------------------------------------

    /**
     * Constructor.
     *
     * @api
     */
    constructor()
    {
        this.setConstants();
        this.setProperties();
    }

   //--------------------------------------------------------------------------

    /**
     * Returns n in text, counting from the left.
     *
     * @example    this.left(string str, int n);
     *             this.left('Manufacturing', 4)  <=>  'Manu'
     *
     * @param {string}  str The string expression
     * @param {integer} n   The numeric expression
     *
     * @return {string} This returns a string of size n
     *
     * @api
     */
    left(str, n)
    {
        str = String(str);
        n = parseInt(n, this.DECIMAL);

        return (n < str.length) ? ((n <= 0) ? '' : str.substring(0, n)) : str;
    }

   //--------------------------------------------------------------------------

    /**
     * Returns the specified n in text, counting from the right.
     *
     * @example    this.right(string str, int n);
     *             this.right('Manufacturing', 4)  <=>  'ring'
     *
     * @param {string}  str The string expression
     * @param {integer} n   The numeric expression
     *
     * @return {string} This returns a string of size n
     *
     * @api
     */
    right(str, n)
    {
        str = String(str);
        let length = str.length;
        n = parseInt(n, this.DECIMAL);

        return (n < length) ? ((n <= 0) ? '' : str.substring(length, length - n)) : str;
    }

    //--------------------------------------------------------------------------

    /**
     * Provides left padding of str with char to a total of n chars.
     *
     * @example    this.leftPad(string str, string char, int n);
     *             this.leftPad(292, '0', 9)     <=> '000000292'
     *             this.leftPad('Smith', '-', 9) <=> '----Smith'
     *
     * @param  {string}  str  The string to pad
     * @param  {string}  char The character string to apply padding
     * @param  {integer} n    The number of characters to return
     *
     * @return {string} This returns a padded string of n chars.
     *
     * @api
     */
    leftPad(str, char, n)
    {
        str = String(str);
        char = String(char);
        n = parseInt(String(n).replace(/[^0-9']/g, ''), this.DECIMAL);

        if (!str || !char || str.length >= n) {
            return str;
        }

        let max = (n - str.length) / char.length;
        for (var i = 0; i < max; i++) {
            str = char + str;
        }

        return str;
    }

    //--------------------------------------------------------------------------

    /**
     * Returns a string produced according to the formatting string format.
     *
     * The format string is composed of zero or more directives: ordinary characters
     * (excluding %) that are copied directly to the result, and conversion
     * specifications, each of which results in fetching its own parameter.
     *
     * Each conversion specification consists of a percent sign (%), followed
     * by one or more of these elements, in order:
     *
     * 1) An optional sign specifier that forces a sign (- or +) to be used
     *    on a number. By default, only the - sign is used on a number if it's
     *    negative. This specifier forces positive numbers to have the + sign
     *    attached as well.
     * 2) An optional padding specifier that says what character will be used
     *    for padding the results to the right string size. This may be a
     *    space character or a 0 (zero character). The default is to pad with
     *    spaces. An alternate padding character can be specified by prefixing
     *    it with a single quote ('). See the examples below.
     * 3) An optional alignment specifier that says if the result should be
     *    left-justified or right-justified. The default is right-justified;
     *    a - character here will make it left-justified.
     * 4) An optional number, a width specifier that says how many characters
     *    (minimum) this conversion should result in.
     * 5) An optional precision specifier in the form of a period (.) followed
     *    by an optional decimal digit string that says how many decimal digits
     *    should be displayed for floating-point numbers. When using this specifier
     *    on a string, it acts as a cutoff point, setting a maximum character limit
     *    to the string. Additionally, the character to use when padding a number
     *    may optionally be specified between the period and the digit.
     * 6) A type specifier that says what type the argument data should be
     *    treated as. Possible types:
     *        % - a literal percent character. No argument is required.
     *        b - the argument is treated as an integer, and presented
     *            as a binary number.
     *        c - the argument is treated as an integer, and presented as the
     *            character with that ASCII value.
     *        d - the argument is treated as an integer, and presented as a
     *            (signed) decimal number.
     *        e - the argument is treated as scientific notation (e.g. 1.2e+2).
     *            The precision specifier stands for the number of digits after the
     *            decimal point since PHP 5.2.1. In earlier versions, it was taken
     *            as number of significant digits (one less).
     *        E - like %e but uses uppercase letter (e.g. 1.2E+2).
     *        f - the argument is treated as a float, and presented as a
     *            floating-point number (locale aware).
     *        F - the argument is treated as a float, and presented as a
     *            floating-point number (non-locale aware).
     *        g - shorter of %e and %f.
     *        G - shorter of %E and %f.
     *        o - the argument is treated as an integer, and presented as an
     *            octal number.
     *        s - the argument is treated as and presented as a string.
     *        u - the argument is treated as an integer, and presented as an
     *            unsigned decimal number.
     *        x - the argument is treated as an integer and presented as a
     *            hexadecimal number (with lowercase letters).
     *        X - the argument is treated as an integer and presented as a
     *            hexadecimal number (with uppercase letters).
     *
     *     TYPE        Specifiers for type handling
     *     ----        ----------------------------
     *     {string}    s
     *     {integer}   d, u, c, o, x, X, b
     *     {double}    g, G, e, E, f, F
     *
     * @example    this.sprintf("%01.2f", 123.1);        <=> '123.10'
     *             this.sprintf("[%10s]", 'monkey');     <=> '[ monkey]'
     *             this.sprintf("[%'#10s]", 'monkey');   <=> '[####monkey]'
     *             this.sprintf("%d", 123456789012345);  <=> '123456789012345'
     *             this.sprintf('%-03s', 'E');           <=> 'E00'
     *
     * @return {string} Return a formatted string
     *
     * @api
     */
    sprintf() {
        let regex = /%%|%(\d+\$)?([\-+'#0 ]*)(\*\d+\$|\*|\d+)?(?:\.(\*\d+\$|\*|\d+))?([scboxXuideEfFgG])/g;
        let a = arguments;
        let i = 0;
        let format = a[i++];

        let _pad = function(str, len, chr, leftJustify) {
            if (!chr) {
                chr = ' ';
            }
            let padding = (str.length >= len) ? '' : new Array(1 + len - str.length >>> 0).join(chr);

            return leftJustify ? str + padding : padding + str;
        };

        let justify = function(value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {
            let diff = minWidth - value.length;
            if (diff > 0) {
                if (leftJustify || !zeroPad) {
                    value = _pad(value, minWidth, customPadChar, leftJustify);
                } else {
                    value = [value.slice(0, prefix.length), _pad('', diff, '0', true), value.slice(prefix.length)].join('');
                }
            }

            return value;
        };

        let _formatBaseX = function(value, base, prefix, leftJustify, minWidth, precision, zeroPad) {
            let number = value >>> 0;
            prefix = (prefix && number && {'2': '0b', '8': '0', '16': '0x'}[base]) || '';
            value = prefix + _pad(number.toString(base), precision || 0, '0', false);

            return justify(value, prefix, leftJustify, minWidth, zeroPad);
        };

        let _formatString = function(value, leftJustify, minWidth, precision, zeroPad, customPadChar) {
            if (precision !== null && precision !== undefined) {
                value = value.slice(0, precision);
            }

            return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);
        };

        let doFormat = function(substring, valueIndex, flags, minWidth, precision, type) {
            let number, prefix, method, textTransform, value;
            if (substring === '%%') {
                return '%';
            }

            let leftJustify = false;
            let positivePrefix = '';
            let zeroPad = false;
            let prefixBaseX = false;
            let customPadChar = ' ';
            let flagsl = flags.length;
            let j;
            for (j = 0; j < flagsl; j++) {
                switch (flags.charAt(j)) {
                    case ' ': positivePrefix = ' '; break;
                    case '+': positivePrefix = '+'; break;
                    case '-': leftJustify = true; break;
                    case "'": customPadChar = flags.charAt(j + 1); break;
                    case '0': zeroPad = true; customPadChar = '0'; break;
                    case '#': prefixBaseX = true; break;
                }
            }

            if (!minWidth) {
                minWidth = 0;
            } else if (minWidth === '*') {
                minWidth = +a[i++];
            } else if (minWidth.charAt(0) === '*') {
                minWidth = +a[minWidth.slice(1, -1)];
            } else {
                minWidth = +minWidth;
            }

            if (minWidth < 0) {
                minWidth = -minWidth;
                leftJustify = true;
            }

            if (!isFinite(minWidth)) {
                throw new Error('sprintf: (minimum-)width must be finite');
            }

            if (!precision) {
                precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type === 'd') ? 0 : undefined;
            } else if (precision === '*') {
                precision = +a[i++];
            } else if (precision.charAt(0) === '*') {
                precision = +a[precision.slice(1, -1)];
            } else {
                precision = +precision;
            }

            value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];

            switch (type) {
                case 's': return _formatString(value + '', leftJustify, minWidth, precision, zeroPad, customPadChar);
                case 'c': return _formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);
                case 'b': return _formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
                case 'o': return _formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
                case 'x': return _formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
                case 'X': return _formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();
                case 'u': return _formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
                case 'i':
                case 'd': number = +value || 0;
                          number = Math.round(number - number % 1);
                          prefix = number < 0 ? '-' : positivePrefix;
                          value = prefix + _pad(String(Math.abs(number)), precision, '0', false);
                          return justify(value, prefix, leftJustify, minWidth, zeroPad);
                case 'e':
                case 'E':
                case 'f':
                case 'F':
                case 'g':
                case 'G': number = +value;
                          prefix = number < 0 ? '-' : positivePrefix;
                          method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];
                          textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];
                          value = prefix + Math.abs(number)[method](precision);
                          return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();
                 default: return substring;
            }
        };

        return format.replace(regex, doFormat);
    }

    //--------------------------------------------------------------------------

    /**
     * Return all the values of an array.
     *
     * @example    this.array_values(string list);
     *             this.array_values({firstname: 'John', lastname: 'Deere'})   <=>  ['John', 'Deere']
     *
     * @param {array} list The searched value
     *
     * @return {array} Returns an indexed array of values.
     *
     * @api
     */
    array_values(list) // eslint-disable-line camelcase
    {
        let tmpArr = [];
        let key = '';

        for (key in list) {
            tmpArr[tmpArr.length] = list[key];
        }

        return tmpArr;
    }

    //--------------------------------------------------------------------------

    /**
     * Checks if the given key or index exists in the array.
     *
     * Returns TRUE if the given key is set in the array. key can be any
     * value possible for an array index.
     *
     * @example    this.array_key_exists(string key, array list);
     *             this.array_key_exists('City', {'City': 'Steamboat Springs'})   <=>  true
     *
     * @param {mixed} key  The value to check.
     * @param {array} list The array with keys to check.
     *
     * @return {boolean} Returns TRUE on success or FALSE on failure.
     *
     * @api
     */
    array_key_exists(key, list) // eslint-disable-line camelcase
    {
        if (!list || (list.constructor !== Array && list.constructor !== Object)) {
            return false;
        }

        return key in list;
    }

    //--------------------------------------------------------------------------

    /**
     * Merge one or more arrays.
     *
     * Merges the elements of one or more arrays together so that the values
     * of one are appended to the end of the previous one. It returns the resulting array.
     *
     * @example    this.array_merge(array one, array two, ...);
     *             let $arr1 = {"color": "red", 0: 2, 1: 4}
     *             let $arr2 = {0: "a", 1: "b", "color": "green", "shape": "trapezoid", 2: 4}
     *             this.array_merge($arr1, $arr2) <=> {"color": "green", 0: 2, 1: 4, 2: "a", 3: "b", "shape": "trapezoid", 4: 4}
     *
     *             let $arr1 = []
     *             let $arr2 = {1: "data"}
     *             this.array_merge($arr1, $arr2)  <=>  {0: "data"}
     *
     * @return {array} Returns the resulting array.
     *
     * @api
     */
    array_merge() // eslint-disable-line camelcase
    {
        let args = Array.prototype.slice.call(arguments);
        let argl = args.length;
        let arg;
        let retObj = {};
        let k = '';
        let argil = 0;
        let j = 0;
        let i = 0;
        let ct = 0;
        let toStr = Object.prototype.toString;
        let retArr = true;

        for (i = 0; i < argl; i++) {
            if (toStr.call(args[i]) !== '[object Array]') {
                retArr = false;
                break;
            }
        }

        if (retArr) {
            retArr = [];
            for (i = 0; i < argl; i++) {
                retArr = retArr.concat(args[i]);
            }
            return retArr;
        }

        for (i = 0, ct = 0; i < argl; i++) {
            arg = args[i];
            if (toStr.call(arg) === '[object Array]') {
                for (j = 0, argil = arg.length; j < argil; j++) {
                    retObj[ct++] = arg[j];
                }
            } else {
                for (k in arg) {
                    if (arg.hasOwnProperty(k)) {
                        if (parseInt(k, 10) + '' === k) {
                            retObj[ct++] = arg[k];
                        } else {
                            retObj[k] = arg[k];
                        }
                    }
                }
            }
        }

        return retObj;
    }

    //--------------------------------------------------------------------------

    /**
     * Checks if a value exists in an array.
     *
     * @example    this.in_array(string needle, array haystack, boolean paramStrict);
     *             this.in_array('van', ['Kevin', 'van', 'Zonneveld'])                 <=>  true
     *             this.in_array('vlado', {0: 'Kevin', vlado: 'van', 1: 'Zonneveld'})  <=>  false
     *             this.in_array(1, ['1', '2', '3'])         <=>  true
     *             this.in_array(1, ['1', '2', '3'], false)  <=>  true
     *             this.in_array(1, ['1', '2', '3'], true)   <=>  false
     *
     * @param {string}  needle      The searched value
     * @param {integer} haystack    The array
     * @param {boolean} paramStrict The strict parameter (if set to TRUE, then will also check the types of the needle in the haystack.)
     *
     * @return {boolean} Returns TRUE if needle is found in the array, FALSE otherwise
     *
     * @api
     */
    in_array(needle, haystack, paramStrict = false) // eslint-disable-line camelcase
    {
        let key = '';
        let strict = !!paramStrict;

        if (strict) {
            for (key in haystack) {
                if (haystack[key] === needle) {
                    return true;
                }
            }
        } else {
            for (key in haystack) {
                if (haystack[key] == needle) { // eslint-disable-line eqeqeq
                    return true;
                }
            }
        }

        return false;
    }

    //--------------------------------------------------------------------------

    /**
     * Return all the keys or a subset of the keys of an array.
     *
     * @example    this.array_keys(string array, string searchValue, boolean paramStrict);
     *             this.array_keys({firstname: 'Kevin', surname: 'van Zonneveld'}) <=> ['firstname', 'surname']
     *
     * @param {Array}   array       The array containing keys to return
     * @param {string}  searchValue The value to search
     * @param {boolean} paramStrict The strict parameter (if set to TRUE, then will use strict comparison: ===.)
     *
     * @return {array} Returns an array of all the keys in array.
     *
     * @api
     */
    array_keys(array, searchValue = null, paramStrict = false) { // eslint-disable-line camelcase
        var key = '';
        var _flag = true;
        var tmpArray = [];
        var _strict = !!paramStrict;
        var _search = (this.showType(searchValue) !== 'null');

        for (key in array) {
            if (array.hasOwnProperty(key)) {
                _flag = true;
                if (_search) {
                    if (_strict && array[key] !== searchValue) {
                        _flag = false;
                    } else if (array[key] !== searchValue) {
                        _flag = false;
                    }
                }
                if (_flag === true) {
                    tmpArray[tmpArray.length] = key;
                }
            }
        }

        return tmpArray;
    }

    //--------------------------------------------------------------------------

    /**
     * Provides right padding of str with char to a total of n chars.
     *
     * @example    this.rightPad(string str, string char, int n);
     *             this.rightPad(45, '*', 9)      <=> '45*******'
     *             this.rightPad('Smith', '-', 9) <=> 'Smith----'
     *
     * @param  {string}  str  The string to pad
     * @param  {string}  char The charater string to apply padding
     * @param  {integer} n    The number of characters to return
     *
     * @return {string} This returns a padded string of n chars.
     *
     * @api
     */
    rightPad(str, char, n)
    {
        str = String(str);
        char = String(char);
        n = parseInt(String(n).replace(/[^0-9']/g, ''), this.DECIMAL);

        if (!str || !char || str.length >= n) {
            return str;
        }
        let max = (n - str.length) / char.length;
        for (var i = 0; i < max; i++) {
            str += char;
        }

        return str;
    }

    //--------------------------------------------------------------------------

    /**
     * Get a new version 4 UUID each time this is called.
     *
     * UUIDs v.4 depends primarily on random numbers. The algorithm sets the version
     * number (4 bits) as well as two reserved bits. All other bits (the remaining 122 bits)
     * are set using a random or pseudorandom data source.
     *
     * {@see FRC 4122: https://tools.ietf.org/html/rfc4122}
     *
     * @example    this.
     *             this.getUuid4() <=> '4414b07a-d8ae-4763-a7e2-aa66cb0dc3d0'
     *             this.getUuid4().toUpperCase() <=> 'FC91F49D-DF5A-45C0-A54C-480B05F9CA15'
     *
     * @return {string} This returns a new valid UUID v.4 identifier.
     *
     * @api
     */
    getUuid4() {
        let pattern = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';

        return pattern.replace(/[xy]/g, function (c) {
            let r = Math.random() * 16 | 0, v = c === 'x'
                ? r
                : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    //--------------------------------------------------------------------------

    /**
     * Split a string by string.
     *
     * This JavaScript function does much the same as the PHP equivalent.
     *
     * @example       explode(' ', 'John Deere Equipment')  <=>  ['John','Deere','Equipment']
     * @dependencies  None
     *
     * @param {string}  delimiter The boundary string.
     * @param {string}  string    The input string.
     * @param {integer} limit     If limit is set and positive, the returned array
     *                            will contain a maximum of limit elements with the
     *                            last element containing the rest of string.
     *                            If the limit parameter is negative, all components
     *                            except the last -limit are returned.
     *                            If the limit parameter is zero, then this is treated as 1.
     *
     * @return {array} Returns an array of strings created by splitting the
     *                 string parameter on boundaries formed by the delimiter.
     */
    explode(delimiter, string, limit) {
        if (arguments.length < 2 || typeof delimiter === 'undefined' || typeof string === 'undefined') {
            return null;
        }
        if (delimiter === '' || delimiter === false || delimiter === null) {
            return false;
        }
        if (typeof delimiter === 'function' || typeof delimiter === 'object' || typeof string === 'function' || typeof string === 'object') {
            return {0: ''};
        }
        if (delimiter === true) {
            delimiter = '1';
        }
        delimiter += '';
        string += '';
        var s = string.split(delimiter);
        if (typeof limit === 'undefined') {
            return s;
        }
        if (limit === 0) {
            limit = 1;
        }
        if (limit > 0) {
            if (limit >= s.length) {
                return s;
            }
            return s.slice(0, limit - 1).concat([s.slice(limit - 1).join(delimiter)]);
        }
        if (-limit >= s.length) {
            return [];
        }
        s.splice(s.length + limit);

        return s;
    }

    //--------------------------------------------------------------------------

    /**
     * Get the class version number.
     *
     * @example    this.getVersion();
     *             this.getVersion()  <=>  '1.28.0'
     *
     * @return {string} Returns a string with framework version number
     *
     * @api
     */
    getVersion()
    {
        return this.version;
    }

    //--------------------------------------------------------------------------

    /**
     * Provides an improved version of the typeOf operator.
     *
     * Taken from a very good article discussing issues of the 'typeof'
     * operator in JavaScript and a way to fix these issues.
     * {@see https://javascriptweblog.wordpress.com/2011/08/08/fixing-the-javascript-typeof-operator/}
     *
     * @example    this.showType(mixed obj);
     *             let sample = true;
     *             this.toType(sample)  <=>  'boolean'
     *
     * @param  {mixed} obj The item to check
     *
     * @return {string} The assigned type for the variable
     *
     * @api
     */
    showType(obj)
    {
        return ({}).toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
    }

    //--------------------------------------------------------------------------

    /**
     * Get the class name for the object.
     *
     * @example    this.getClassName(object obj);
     *             this.getClassName(service)  <=>  'ServiceContainer'
     *
     * @param {object} obj The object instance
     *
     * @return {string} Returns the class name of the object
     *
     * @api
     */
    getClassName(obj)
    {
        return (this.showType(obj) === 'boolean' && obj === false) ? 'FALSE' : obj.constructor.name;
    }

    //--------------------------------------------------------------------------
}

export default AbstractFunctions;
